# ACTIVIDAD 4:
1.	Abrí page2.html en el navegador con el servidor corriendo y accedí a la consola de desarrollador (F12). Luego, detuve el servidor de Node.js (Ctrl+C). Al refrescar la página de page2.html, pude ver un error en el navegador localhost rechazó la conexión, ya que la conexión Socket.IO no podía establecerse debido a que el servidor no estaba en ejecución.
Después, volví a iniciar el servidor y refresqué la página. Los errores desaparecieron y la conexión se estableció correctamente.

2.	Comenté la línea que envía el estado inicial de page2 al servidor. Al reiniciar y mover la ventana de page2, en page1 no se tenía la información correcta hasta que page2 actualizó el estado manualmente. Al descomentar la línea, page1 recibe el estado inicial de page2 al conectarse, lo que asegura que la información esté sincronizada desde el principio y mejora la comunicación entre las páginas.
3.	Al abrir ambas páginas y mover la ventana de page1, vi que en la consola de page2 se disparaba el log "Page 2 received data about the other window: {x: 241, y: 54, width: 743, height: 664}" con los datos de page1. Esto sucedió porque el servidor envió los datos actualizados de page1 a page2 mediante broadcast.emit. Sin embargo, cuando moví la ventana de page2, no vi el log en su consola porque page2 no envió nada al servidor que hiciera que este disparara el evento getdata. Esto muestra cómo la comunicación entre las páginas depende de las actualizaciones que el servidor emite y recibe.
4.	Cuando moví la ventana de page2 muy lentamente, el mensaje "Page 2 detected change..." apareció en la consola cada vez que detectaba un cambio significativo en la posición o tamaño de la ventana. Esto ocurrió solo cuando hubo un cambio real, lo que significa que no se estaba enviando información innecesaria al servidor en cada frame, lo que ahorra recursos y mejora el rendimiento. Si dejaba la ventana de page2 quieta, no veía el mensaje porque no hubo cambios en el estado de la ventana. Esta estrategia de comparar el estado actual con el anterior antes de enviar datos es eficiente porque reduce el número de actualizaciones enviadas al servidor, asegurando que solo se envíen datos cuando realmente hay algo nuevo que comunicar.
